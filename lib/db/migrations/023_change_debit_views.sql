-- CREATE MATERIALIZED VIEW IF NOT EXISTS stg_debit_summed AS
--
-- -- We discard all unrelevant data already replaced by newer data by the end of the period
-- -- No need to keep "numero_historique_ecart_negatif", as
-- -- "periode_prise_en_compte" allows to sort in the right order
-- WITH debits_simplified AS (
--   SELECT DISTINCT ON (siret, periode_debut, periode_fin, numero_ecart_negatif, periode_prise_en_compte)
--         siret,
--         periode_debut,
--         periode_fin,
--         numero_ecart_negatif,
--         part_ouvriere,
--         part_patronale,
--         periode_prise_en_compte
--   FROM stg_debit
--   WHERE LEFT(siret, 9) IN (select siren FROM sfdata.clean_filter)
--   ORDER BY siret, periode_debut, periode_fin, numero_ecart_negatif, periode_prise_en_compte, numero_historique_ecart_negatif DESC
-- ),
--
-- -- We sum "part_ouvriere" and "part_patronale" for all "numero_ecart_negatif" for each period with data
--   SELECT
--       siret,
--       periode_prise_en_compte,
--       sum(part_ouvriere) AS part_ouvriere,
--       sum(part_patronale) AS part_patronale
--   FROM debits_simplified
--   GROUP BY siret, periode_prise_en_compte;
--
--
-- CREATE INDEX idx_stg_debit_summed_siret_periode
-- ON stg_debit_summed(siret, periode_prise_en_compte DESC);
--
-- DROP MATERIALIZED VIEW IF EXISTS clean_debit CASCADE;
--
-- CREATE MATERIALIZED VIEW IF NOT EXISTS clean_debits AS
--
-- -- for every siret x period, get last available value of part_ouvriere & part_patronale
-- WITH unique_sirets AS (
--   SELECT DISTINCT siret
--   FROM debits_summed
-- ),
-- periodes AS (
--     SELECT date_trunc('month', current_date) - generate_series(1, 24) * '1 month'::interval AS periode
-- )
--
-- SELECT
--   s.siret,
--   p.periode,
--   last_value.part_patronale,
--   last_value.part_ouvriere
-- FROM unique_sirets s
-- CROSS JOIN LATERAL periodes p
-- CROSS JOIN LATERAL (
--   SELECT
--     part_patronale,
--     part_ouvriere
--   FROM debits_summed d
--   WHERE d.siret = s.siret
--     AND d.periode_prise_en_compte <= p.periode
--   ORDER BY d.periode_prise_en_compte DESC
--   LIMIT 1
-- ) last_value;
--
-- CREATE INDEX IF NOT EXISTS idx_clean_debit_siret ON clean_debit(siret);
-- CREATE INDEX IF NOT EXISTS idx_clean_debit_periode ON clean_debit(periode);
