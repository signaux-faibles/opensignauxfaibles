package engine

import (
	"encoding/json"
	"path/filepath"
	"strings"

	"github.com/globalsign/mgo/bson"
)

//go:generate go run validation/bundle-schemas.go

// This file loads validationSchemas from validationSchemas.go,
// generated by validation/bundle-schemas.go, on `go generate`.

// MakeValidationSchemaForImportedData génère un schéma pour valider les documents JSON de ImportedData.
func MakeValidationSchemaForImportedData(schemaPerHashedDataType map[string]bson.M) bson.M {
	return bson.M{
		"bsonType": "object",
		"properties": bson.M{
			"_id": bson.M{"bsonType": "objectId"},
			"value": bson.M{
				"bsonType": "object",
				"properties": bson.M{
					"scope": bson.M{"bsonType": "string", "enum": []string{"etablissement", "entreprise"}},
					"key":   bson.M{"bsonType": "string", "pattern": "[0-9]+"}, // SIREN ou SIRET
					"batch": wrapValidationSchemaBehindBatchId(bson.M{
						"bsonType":             "object",
						"properties":           schemaPerHashedDataType,
						"additionalProperties": false,
					}),
				},
				"additionalProperties": false,
			},
		},
		"additionalProperties": false,
	}
}

// MakeValidationSchemaPerHashedDataType génère un dictionnaire associant chaque type
// de données à un JSON Schema permettant de valider les données
// correspondantes, rattachées à un Hash. (cf structure de ImportedData)
func MakeValidationSchemaPerHashedDataType(jsonSchemas map[string]bson.M) map[string]bson.M {
	schemas := map[string]bson.M{}
	for dataType, schema := range jsonSchemas {
		schemas[dataType] = wrapValidationSchemaBehindHash(schema)
	}
	return schemas
}

// wrapValidationSchemaBehindHash rattache un JSON Schema à un "data hash".
// (cf structure de ImportedData)
func wrapValidationSchemaBehindHash(jsonSchema bson.M) bson.M {
	return bson.M{
		"bsonType":             "object",
		"patternProperties":    bson.M{"[0-9a-f]+": jsonSchema},
		"additionalProperties": false,
	}
}

// wrapValidationSchemaBehindBatchId rattache un JSON Schema à un BatchId.
// (cf structure de ImportedData)
func wrapValidationSchemaBehindBatchId(jsonSchema bson.M) bson.M {
	return bson.M{
		"bsonType":             "object",
		"patternProperties":    bson.M{"[0-9_]+": jsonSchema},
		"additionalProperties": false,
	}
}

func parseJSONObject(content string) (object bson.M, err error) {
	err = json.Unmarshal([]byte(content), &object) // transform json string into bson.M
	return object, err
}

func parseJSONArray(content string) (array []bson.M, err error) {
	err = json.Unmarshal([]byte(content), &array) // transform json string into bson.M
	return array, err
}

// LoadJSONSchemaFiles cherche les Schemas JSON pour GetRawDataValidationPipeline.
func LoadJSONSchemaFiles() (jsonSchema map[string]bson.M, err error) {
	jsonSchema = make(map[string]bson.M)
	for filename, content := range validationSchemas {
		if strings.Contains(filename, ".schema.json") {
			dataType := strings.Replace(filepath.Base(filename), ".schema.json", "", 1)
			jsonSchema[dataType], err = parseJSONObject(content)
			if err != nil {
				return nil, err
			}
		}
	}
	return jsonSchema, nil
}

// GetUndefinedDataValidationPipeline produit un pipeline pour détecter les entrées `undefined` depuis RawData ou ImportedData.
func GetUndefinedDataValidationPipeline() (pipeline []bson.M, err error) {
	return parseJSONArray(validationSchemas["detect_invalid_entries.pipeline.json"])
}

// GetDataValidationPipeline produit un pipeline pour retourner la listes des documents invalides depuis RawData ou ImportedData.
func GetDataValidationPipeline(jsonSchema map[string]bson.M) (pipeline []bson.M, err error) {

	flattenPipeline, err := parseJSONArray(validationSchemas["flatten_data_entries.pipeline.json"])
	if err != nil {
		return nil, err
	}

	pipeline = append(pipeline, flattenPipeline...)

	matchers := []bson.M{}
	for dataType, schema := range jsonSchema {
		matchers = append(matchers, bson.M{
			"dataType": dataType,
			"$nor": []bson.M{ // "To find documents in the collection that do not satisfy the specified schema, use the $jsonSchema expression in a $nor expression" (https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#query-conditions)
				{
					"$jsonSchema": bson.M{
						"bsonType": "object",
						"properties": bson.M{
							"dataObject": schema,
						},
					},
				},
			},
		})
	}

	pipeline = append(pipeline, bson.M{
		"$match": bson.M{
			"$or": matchers,
		},
	})
	return pipeline, nil
}
